"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const vue = require("vue");
const ui = require("@tonconnect/ui");
class TonConnectUIVueError extends ui.TonConnectUIError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectUIVueError.prototype);
  }
}
class TonConnectProviderNotSetError extends TonConnectUIVueError {
  constructor(...args) {
    super(...args);
    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);
  }
}
const checkProvider = (provider) => {
  if (!provider) {
    throw new TonConnectProviderNotSetError(
      "You should add <TonConnectUIProvider> on the top of the app to use TonConnect"
    );
  }
  return true;
};
const TonConnectUIContext = Symbol("TonConnectUIContext");
const TonConnectUIOptionsContext = Symbol("TonConnectUIOptionsContext");
let tonConnectUI = null;
function createTonConnectUIProvider(options) {
  const tonConnectUIRef = vue.ref(null);
  if (typeof window !== "undefined" && !tonConnectUI) {
    tonConnectUI = new ui.TonConnectUI(options);
    tonConnectUIRef.value = tonConnectUI;
  }
  const setOptions = (options2) => {
    if (tonConnectUI) {
      tonConnectUI.uiOptions = options2;
    }
  };
  return {
    tonConnectUI: tonConnectUIRef,
    setOptions
  };
}
function useTonConnectUIProvider() {
  const tonConnectUI2 = vue.inject(TonConnectUIContext);
  const setOptions = vue.inject(TonConnectUIOptionsContext);
  if (!tonConnectUI2 || !setOptions) {
    throw new Error("TonConnectUIProvider is not properly initialized.");
  }
  return { tonConnectUI: tonConnectUI2, setOptions };
}
function useTonConnectUI() {
  const { tonConnectUI: tonConnectUI2, setOptions } = useTonConnectUIProvider();
  vue.watchEffect(() => {
    if (typeof window !== "undefined") {
      checkProvider(tonConnectUI2.value);
    }
  });
  const updateOptions = (options) => {
    setOptions(options);
  };
  return { tonConnectUI: tonConnectUI2, updateOptions };
}
function useTonWallet() {
  var _a;
  const { tonConnectUI: tonConnectUI2 } = useTonConnectUI();
  const wallet = vue.ref(
    ((_a = tonConnectUI2.value) == null ? void 0 : _a.wallet) || null
  );
  const updateWallet = (value) => {
    wallet.value = value;
  };
  vue.onMounted(() => {
    if (tonConnectUI2.value) {
      wallet.value = tonConnectUI2.value.wallet;
      tonConnectUI2.value.onStatusChange(updateWallet);
    }
  });
  vue.onUnmounted(() => {
    if (tonConnectUI2.value) {
      tonConnectUI2.value.onStatusChange(updateWallet);
    }
  });
  return wallet;
}
function useTonAddress(userFriendly = true) {
  const wallet = useTonWallet();
  const address = vue.computed(() => {
    if (wallet.value) {
      return userFriendly ? ui.toUserFriendlyAddress(
        wallet.value.account.address,
        wallet.value.account.chain === ui.CHAIN.TESTNET
      ) : wallet.value.account.address;
    } else {
      return "";
    }
  });
  return address;
}
function useTonConnectModal() {
  var _a;
  const { tonConnectUI: tonConnectUI2 } = useTonConnectUI();
  const state = vue.ref(
    ((_a = tonConnectUI2.value) == null ? void 0 : _a.modal.state) || null
  );
  const updateState = (value) => {
    state.value = value;
  };
  vue.onMounted(() => {
    if (tonConnectUI2.value) {
      state.value = tonConnectUI2.value.modal.state;
      tonConnectUI2.value.onModalStateChange(updateState);
    }
  });
  vue.onUnmounted(() => {
    if (tonConnectUI2.value) {
      tonConnectUI2.value.onModalStateChange(updateState);
    }
  });
  const open = () => {
    var _a2;
    (_a2 = tonConnectUI2.value) == null ? void 0 : _a2.modal.open();
  };
  const close = () => {
    var _a2;
    (_a2 = tonConnectUI2.value) == null ? void 0 : _a2.modal.close();
  };
  return {
    state,
    open,
    close
  };
}
function useIsConnectionRestored() {
  const { tonConnectUI: tonConnectUI2 } = useTonConnectUI();
  const restored = vue.ref(false);
  vue.onMounted(() => {
    if (tonConnectUI2.value) {
      tonConnectUI2.value.connectionRestored.then(() => {
        restored.value = true;
      });
    }
  });
  return restored;
}
function useSendTransaction() {
  const { tonConnectUI: tonConnectUI2 } = useTonConnectUI();
  const sending = vue.ref(false);
  const error = vue.ref(null);
  const messages = vue.ref([]);
  const addMessage = (address, amount) => {
    messages.value.push({ address, amount });
  };
  const clearMessages = () => {
    messages.value = [];
  };
  const sendTransaction = () => __async(this, null, function* () {
    var _a;
    if (!tonConnectUI2.value) {
      error.value = new Error("TonConnect UI is not initialized.");
      return;
    }
    if (messages.value.length === 0) {
      error.value = new Error("No transaction messages to send.");
      return;
    }
    sending.value = true;
    error.value = null;
    try {
      yield tonConnectUI2.value.connector.sendTransaction({
        validUntil: Math.floor(Date.now() / 1e3) + 360,
        messages: messages.value
      });
    } catch (err) {
      if ((_a = err == null ? void 0 : err.message) == null ? void 0 : _a.includes("User rejects the action")) {
        error.value = new Error("Transaction was rejected by the user.");
      } else {
        error.value = err;
      }
    } finally {
      sending.value = false;
    }
  });
  return {
    sendTransaction,
    sending,
    error,
    messages,
    addMessage,
    clearMessages
  };
}
const _sfc_main = vue.defineComponent({
  name: "TonConnectButton",
  props: {
    className: {
      type: String,
      default: ""
    },
    style: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const buttonRootId = "ton-connect-button";
    const { updateOptions } = useTonConnectUI();
    vue.onMounted(() => {
      updateOptions({ buttonRootId });
    });
    vue.onUnmounted(() => {
      updateOptions({ buttonRootId: null });
    });
    vue.watch(
      () => props.style,
      (newStyle) => {
        console.log(newStyle);
      }
    );
    return {
      buttonRootId,
      className: vue.ref(props.className),
      style: vue.ref(props.style)
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    id: _ctx.buttonRootId,
    class: vue.normalizeClass(_ctx.className),
    style: vue.normalizeStyle(__spreadValues({ width: "fit-content" }, _ctx.style))
  }, null, 14, _hoisted_1);
}
const TonConnectButton = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const isClient = () => {
  return typeof window !== "undefined";
};
const isServer = () => {
  return !isClient();
};
exports.TonConnectButton = TonConnectButton;
exports.TonConnectProviderNotSetError = TonConnectProviderNotSetError;
exports.TonConnectUIContext = TonConnectUIContext;
exports.TonConnectUIOptionsContext = TonConnectUIOptionsContext;
exports.TonConnectUIVueError = TonConnectUIVueError;
exports.checkProvider = checkProvider;
exports.createTonConnectUIProvider = createTonConnectUIProvider;
exports.isClient = isClient;
exports.isServer = isServer;
exports.useIsConnectionRestored = useIsConnectionRestored;
exports.useSendTransaction = useSendTransaction;
exports.useTonAddress = useTonAddress;
exports.useTonConnectModal = useTonConnectModal;
exports.useTonConnectUI = useTonConnectUI;
exports.useTonConnectUIProvider = useTonConnectUIProvider;
exports.useTonWallet = useTonWallet;
Object.keys(ui).forEach((k) => {
  if (k !== "default" && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: () => ui[k]
  });
});
//# sourceMappingURL=index.cjs.map
